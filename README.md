# SYSC4005-Project
##Project Deliverable 1
Group #: 13
Students: Johnny Mack (#101029263), Sebastian Ross (#101073435)
Instructor: Changcheng Huang
Due Date: February 10th, 2022
##Problem Formulation
The goal of this project is to design a simulation program for a manufacturing facility. The manufacturing facility produces three types of products, named P1, P2, and P3. There are also three types of components, named C1, C2, and C3. Each product consists of a certain combination of components. More specifically, product P1 consists of one component C1, product P2 consists of one component C1 and one component C2, and product P3 consists of one component C1 and one component C3.
Each component must be inspected by an inspector before being placed into  a component buffer for a workstation. Inspector 1 works on C1 components, and inspector 2 works on C2 and C3 components in a random order. All components are infinitely available and instructors will never have to wait for components to arrive.
There are three workstations, named W1, W2, and W3. They assemble products P1, P2, and P3, respectively. Each workstation has a buffer for each component required to make its respective product (that is, W1 has one buffer, while W2 and W3 both have two buffers), with each buffer having space to hold two components. A product can only be assembled when components of all types are available.
If an inspector finishes inspecting a component but all buffers which accept that type of component are full, then that inspector is considered “blocked” until there is an opening. Once there is an opening, then the blocked inspector may resume processing components of that type.
In the present mode of operation, Inspector 1 routes components C1 to the buffer with the smallest number of components in the queue. In case of a tie, W1 has the highest priority and W3 has the lowest priority.
##Setting of Objectives and Overall Project Plan
The objective of the project is to optimize the facility’s throughput. This is accomplished by monitoring various measurements including the probability that each workstation is busy, the average occupancy of each buffer, and the probability that each inspector remains blocked.
There is an additional objective that can be achieved. The additional objective is altering the policy that Inspector 1 follows when delivering C1 components to the different workstations in such a way that increases the facility’s throughput and/or decreases the inspector’s blocked time.
The first deliverable of this project is captured in this document. This document consists of the problem formulation, setting of objectives and overall project plan, model conceptualization, and model translation of the manufacturing facility. The second deliverable will contain the data collection and input modeling. The third deliverable will pertain to model verification and validation, as well as production runs and analysis. Lastly, the fourth deliverable will address alternative operating policies, the conclusion, and a final report.
The dates for which these project deliverables are due have not been announced yet, with the exception of this deliverable (deliverable 1). Deliverable 1 of this project is due on February 10th, 2022.
##Model Conceptualization
The model for the manufacturing facility has been provided in the assignment document.
![Diagram of the organization of the parts of the manufacturing facility](https://github.com/TheSebastianRoss/SYSC4005-Project/blob/main/OrganizationalDiagram.png?raw=true)
##Model Translation
Our team decided to use Java to code the simulation program over other programming languages, such as Python and Matlab, because its object-oriented nature facilitates the process of storing the states of entities within the system. Furthermore, it is the programming language that we are most comfortable with.
The following section will discuss the software architecture of the project at a high level. Next, the main functionalities of each class will be highlighted. Finally, we will take a look at the source code at a detailed level.
##Software Architecture
###UML Diagram
![UML Class diagram of the system](https://github.com/TheSebastianRoss/SYSC4005-Project/blob/main/UMLDiagram.png?raw=true)
##Classes and Functions
The simulation project consists of six classes.
###Sim.java
This class represents the simulation itself and contains the entry point for the program. It contains the future event list (FEL) and runs until a certain number of products have left the system. It places two initial arrival events into the FEL (one for Inspector 1 and one for Inspector 2) which are required to begin the simulation. It is responsible for processing and scheduling arrival and departure events. The processing and scheduling of events is accomplished by methods processArrival(), processDeparture(), and scheduleArrival(). There is no scheduleDeparture() method in the Sim.java class. Instead, the scheduling of departures is delegated to Inspector and Workstation instances so that they may use randomly distributed service times to determine the departure times.
This class is also responsible for notifying blocked Inspector instances when there is room in the ComponentQueues via the notifyInspector() method. If the Inspector becomes unblocked, then a new departure event will be added to the FEL with the current clock cycle so that the Inspector may place the inspected component into the appropriate ComponentQueue.
The policy for how Inspector 1 selects which C1 ComponentQueue to place their inspected C1 component into is contained within getShortestAvailableC1Queue(). To analyze how different policies affect the system throughput and inspector blocked times, the getShortestAvailableC1Queue() method could be substituted with other policy methods.
At the end of the simulation, Sim.java calls reportSGeneration() to print a statistical report which contains information such as the total number of clock cycles, the total number of products produced, the system throughput, and the statistics delegated to the other entities within the system (e.g., ComponentQueue.java, Inspector.java, and Workstation.java).
###Inspector.java
This class represents an inspector in the system. Inspectors are responsible for inspecting components upon arrival with a randomly distributed service time. They have access to an infinite and readily available supply of components. The put() method is called by Sim.java when the arrival of a new component at an Inspector is processed. Once an Inspector begins inspecting a component, Sim.java will schedule a new departure event based on the random service time generated by getServiceTime(). When Sim.java processes the departure event for the inspected component, there is a possibility that the Inspector becomes blocked. However, if the Inspector has room to place their inspected component, then the get() method will be called and a new arrival event will be scheduled so that the Inspector may begin inspecting another component.
At the end of the simulation, Inspector.java calls qReportGeneration() to print a statistical report which contains information such as the total time busy, the total time blocked, and the probability of being blocked.
###ComponentQueue.java
This class represents a component queue in the system. ComponentQueues are associated with exactly one Workstation instance. ComponentQueues are responsible for holding inspected components. The put() method is called by Sim.java when processing the arrivals of inspected components at ComponentQueue instances. The put() method places an inspected component into the queue. The get() method is called by Workstation instances whenever they begin the production of a product. The get() method removes the component at the head of the queue.
At the end of the simulation, ComponentQueue.java calls qReportGeneration() to print a statistical report which contains information such as the total number of departures from each ComponentQueue instance as well as their average buffer occupancies.
###Workstation.java
This class represents a workstation in the system. Workstations are associated with one to many (in this case up to two) ComponentQueue instances. Each instance of Workstation requires a component from each of their associated ComponentQueues to begin the production of a product. A Workstation begins production via the service() method which checks if all components are available by calling the canProduce() method. If there is at least one component in each associated ComponentQueue, then production will begin and one component from each ComponentQueue will be consumed by a call to consumeComponents(). The production time of products is randomly distributed by the getServiceTime() method. A new departure event will be scheduled when production begins.
At the end of the simulation, Workstation.java calls qReportGeneration() to print a statistical report which contains information such as the total number of products produced from each Workstation instance as well as the probability of being busy.
###Event.java
This class represents an event in the future event list. It contains information such as the time of the event, the type of event, the entity associated with the event, and the component/product associated with the event. This class implements the Comparable interface so that it can be ordered in the future event list by the simulation clock values.
###EventType.java
A basic enumeration containing event types ARRIVAL and DEPARTURE.